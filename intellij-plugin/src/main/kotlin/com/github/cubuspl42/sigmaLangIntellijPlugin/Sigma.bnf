{
  parserClass="com.github.cubuspl42.sigmaLangIntellijPlugin.parser.SigmaParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  extends(".*_expression")=expression

  psiClassPrefix="Sigma"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.cubuspl42.sigmaLangIntellijPlugin.psi"
  psiImplPackage="com.github.cubuspl42.sigmaLangIntellijPlugin.psi.impl"

  elementTypeHolderClass="com.github.cubuspl42.sigmaLangIntellijPlugin.psi.SigmaTypes"
  elementTypeClass="com.github.cubuspl42.sigmaLangIntellijPlugin.psi.SigmaElementType"
  tokenTypeClass="com.github.cubuspl42.sigmaLangIntellijPlugin.psi.SigmaTokenType"
}

sigma_file ::=
    namespace_body

// # Namespace

namespace_definition ::=
    NAMESPACE_KEYWORD IDENTIFIER <<paren_wrapped namespace_body>>

namespace_body ::= namespace_entry*

namespace_entry ::=
    constant_definition |
    namespace_definition

constant_definition ::=
    CONST_KEYWORD IDENTIFIER ASSIGN expression

// # end

// # Expressions

expression ::=
    unary_group |
    multiplication_group |
    addition_group |
    equals_group |
    primary_group

// private rules to define operators with the same priority
private unary_group ::= unary_negation_expression

private multiplication_group ::= multiplication_expression | division_expression

private addition_group ::= addition_expression | subtraction_expression

private equals_group ::= equals_expression

private primary_group ::=
    // Loose
    if_expression |
    is_undefined_expression |
    let_expression |
    abstraction_constructor | // Must be before tuple_constructor
    compact_expression

compact_expression ::=
    call_expression |
    reference_expression |
    tuple_constructor_expression |
    tuple_type_constructor_expression |
    literal_expression |
    paren_expression |

call_expression ::=
//    expression tuple_constructor_expression
    'CALL'

type_expression ::=
    expression

paren_expression ::=
     <<paren_wrapped expression>>

reference_expression ::=
    IDENTIFIER

if_expression ::=
    IF_KEYWORD expression <<paren_wrapped if_expression_body>>

if_expression_body ::=
    THEN_KEYWORD expression COMMA
    ELSE_KEYWORD expression COMMA?

is_undefined_expression ::=
    IS_UNDEFINED_KEYWORD expression

// public rules for each expression
unary_negation_expression ::= MINUS term
multiplication_expression ::= term ASTERISK term
division_expression ::= term SLASH term
addition_expression ::= term PLUS term
subtraction_expression ::= term MINUS term
equals_expression ::= term EQUALS term

tuple_constructor_expression ::=
    ordered_tuple_constructor |
    unordered_tuple_constructor

ordered_tuple_constructor ::=
    <<bracket_wrapped
        <<list expression>>
    >>

unordered_tuple_constructor ::=
    <<brace_wrapped
        <<list unordered_tuple_entry>>
    >>

// Thought: Is colon the right syntax?
unordered_tuple_entry ::=
    IDENTIFIER COLON expression

tuple_type_constructor_expression ::=
    ordered_tuple_type_constructor |
    unordered_tuple_type_constructor

ordered_tuple_type_constructor ::=
    DASH <<bracket_wrapped
        <<list ordered_tuple_type_constructor_entry>>
    >>

ordered_tuple_type_constructor_entry ::=
    IDENTIFIER type_annotation

unordered_tuple_type_constructor ::=
    DASH <<brace_wrapped
        <<list unordered_tuple_type_constructor_entry>>
    >>

unordered_tuple_type_constructor_entry ::=
    IDENTIFIER COLON type_expression

abstraction_constructor ::=
    generic_parameters_tuple? tuple_type_constructor_expression (THIN_ARROW type_expression)? FAT_ARROW expression

generic_parameters_tuple ::=
    DASH <<bracket_wrapped
        <<list generic_parameter_declaration>>
    >>

generic_parameter_declaration ::=
    IDENTIFIER

let_expression ::=
    LET_KEYWORD <<brace_wrapped let_expression_scope>> IN_KEYWORD expression

let_expression_scope ::=
    <<list let_expression_scope_entry>>

let_expression_scope_entry ::=
    IDENTIFIER type_annotation? ASSIGN expression

literal_expression ::= INT_LITERAL

// # end

type_annotation ::=
    COLON type_expression

private meta paren_wrapped ::= PAREN_LEFT <<p>> PAREN_RIGHT

private meta bracket_wrapped ::= BRACKET_LEFT <<p>> BRACKET_RIGHT

private meta brace_wrapped ::= BRACE_LEFT <<p>> BRACE_RIGHT

private meta list ::= <<p>> (COMMA <<p>>)* COMMA?
