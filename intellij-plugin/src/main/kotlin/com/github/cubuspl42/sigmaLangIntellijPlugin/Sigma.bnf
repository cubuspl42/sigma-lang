{
  parserClass="com.github.cubuspl42.sigmaLangIntellijPlugin.parser.SigmaParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Sigma"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.cubuspl42.sigmaLangIntellijPlugin.psi"
  psiImplPackage="com.github.cubuspl42.sigmaLangIntellijPlugin.psi.impl"

  elementTypeHolderClass="com.github.cubuspl42.sigmaLangIntellijPlugin.psi.SigmaTypes"
  elementTypeClass="com.github.cubuspl42.sigmaLangIntellijPlugin.psi.SigmaElementType"
  tokenTypeClass="com.github.cubuspl42.sigmaLangIntellijPlugin.psi.SigmaTokenType"
}

sigma_file ::=
    namespace_body

// # Namespace

namespace_definition ::=
    NAMESPACE_KEYWORD IDENTIFIER <<paren_wrapped namespace_body>>

namespace_body ::= namespace_entry*

namespace_entry ::=
    constant_definition |
    namespace_definition

constant_definition ::=
    CONST_KEYWORD IDENTIFIER ASSIGN expression

// # end

// # Expressions

expression ::=
    unary_group |
    multiplication_group |
    addition_group |
    equals_group |
    primary_group

// private rules to define operators with the same priority
private unary_group ::= unary_negation_expression

unary_negation_expression ::= MINUS expression
    { extends=expression }

private multiplication_group ::=
    multiplication_expression | division_expression

multiplication_expression ::=
    expression ASTERISK expression
    { extends=expression }

division_expression ::=
    expression SLASH expression
    { extends=expression }

private addition_group ::=
    addition_expression | subtraction_expression

addition_expression ::=
    expression PLUS expression
    { extends=expression }

subtraction_expression ::=
    expression MINUS expression
    { extends=expression }

private equals_group ::=
    equals_expression

equals_expression ::=
    expression EQUALS expression
    { extends=expression }

private primary_group ::=
    call_chain_expression |
    if_expression |
    is_undefined_expression |
    let_expression |
    abstraction_constructor | // Must be before tuple_constructor
    compact_group

private compact_group ::=
    reference_expression |
    paren_expression |
    tuple_constructor  |
    tuple_type_constructor |
    literal

if_expression ::=
    IF_KEYWORD expression <<paren_wrapped if_expression_body>>
    { extends=expression }

if_expression_body ::=
    THEN_KEYWORD expression COMMA
    ELSE_KEYWORD expression COMMA?

is_undefined_expression ::=
    IS_UNDEFINED_KEYWORD expression
    { extends=expression }

let_expression ::=
    LET_KEYWORD <<brace_wrapped let_expression_scope>> IN_KEYWORD expression
    { extends=expression }

let_expression_scope ::=
    <<list let_expression_scope_entry>>

let_expression_scope_entry ::=
    IDENTIFIER type_annotation? ASSIGN expression

abstraction_constructor ::=
    generic_parameters_tuple? tuple_type_constructor (THIN_ARROW type_expression)? FAT_ARROW expression
    { extends=expression }

generic_parameters_tuple ::=
    DASH <<bracket_wrapped
        <<list generic_parameter_declaration>>
    >>

generic_parameter_declaration ::=
    IDENTIFIER

call_chain_expression ::=
    expression tuple_constructor+
    { extends=expression }

reference_expression ::=
    IDENTIFIER
    { extends=expression }

paren_expression ::=
    PAREN_LEFT expression PAREN_RIGHT
    { extends=expression }

tuple_constructor ::=
    ordered_tuple_constructor |
    unordered_tuple_constructor
    { extends=expression }

ordered_tuple_constructor ::=
    <<bracket_wrapped
        <<list expression>>
    >>

unordered_tuple_constructor ::=
    <<brace_wrapped
        <<list unordered_tuple_entry>>
    >>

// Thought: Is colon the right syntax?
unordered_tuple_entry ::=
    IDENTIFIER COLON expression

tuple_type_constructor ::=
    ordered_tuple_type_constructor |
    unordered_tuple_type_constructor
    { extends=expression }

ordered_tuple_type_constructor ::=
    DASH <<bracket_wrapped
        <<list ordered_tuple_type_constructor_entry>>
    >>

ordered_tuple_type_constructor_entry ::=
    IDENTIFIER type_annotation

unordered_tuple_type_constructor ::=
    DASH <<brace_wrapped
        <<list unordered_tuple_type_constructor_entry>>
    >>

unordered_tuple_type_constructor_entry ::=
    IDENTIFIER COLON type_expression

literal ::= INT_LITERAL
    { extends=expression }

// # end

type_expression ::=
    expression

type_annotation ::=
    COLON type_expression

private meta paren_wrapped ::= PAREN_LEFT <<p>> PAREN_RIGHT

private meta bracket_wrapped ::= BRACKET_LEFT <<p>> BRACKET_RIGHT

private meta brace_wrapped ::= BRACE_LEFT <<p>> BRACE_RIGHT

private meta list ::= <<p>> (COMMA <<p>>)* COMMA?
