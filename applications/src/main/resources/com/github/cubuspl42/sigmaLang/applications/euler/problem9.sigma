%const main = %let {
    concatAllOf = ^[e: Type, te: Type] !=> ^[
        list: ^[e...],
        transform: ^[e] -> ^[te...],
    ] -> ^[te...] =>
        concatAll[list:mapX[transform]],

    concatAll = ^[e: Type] !=> ^[
        lists: ^[^[e...]...],
    ] -> ^[e...] => %let {
        recurse = ^{
            listAccumulated: ^[e...],
            listsRemaining: ^[^[e...]...],
        } -> ^[e...] => extractHead[listsRemaining, {
            ifExtracted: ^[
                listsRemainingHead: ^[e...],
                listsRemainingTail: ^[^[e...]...],
            ] => recurse{
                listAccumulated: concat[listAccumulated, listsRemainingHead],
                listsRemaining: listsRemainingTail,
            },
            ifEmpty: listAccumulated,
        }]
    } %in recurse{
        listAccumulated: [],
        listsRemaining: lists,
    },

    range = ^[start: Int, end: Int] -> ^[Int...] => %if end < start (
        %then [],
        %else concat[[start], range[start + 1, end]],
    ),

    tripletsSummingTo = ^[n: Int] =>
        concatAllOf[range[1, n], ^[a: Int] =>
            map[range[1, n], ^[b: Int] =>
                {a: a, b: b, c: n - a - b}
            ]
        ],

    extractHead = ^[e: Type, r: Type] !=> ^[
        list: ^[e...],
        branches: ^{
            ifExtracted: ^[
                head: e,
                tail: ^[e...],
            ] -> r,
            ifEmpty: r,
        },
    ] => %if length[list] > 0 (
        %then branches.ifExtracted[
            list(0),
            dropFirst[list],
        ],
        %else branches.ifEmpty,
    )
} %in tripletsSummingTo[10](0)
