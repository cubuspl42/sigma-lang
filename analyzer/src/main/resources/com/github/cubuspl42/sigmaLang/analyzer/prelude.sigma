%const maxOf = !^[e: Type, te: Type] ^[
    elements: ^[e...],
    transform: ^[e] -> te,
] => max[
    map[elements, transform],
]

%const upTo = ^[
    start: Int,
    end: Int,
] -> ^[Int...] => %if start >= end (
    %then [],
    %else concat[
        [start],
        upTo[start + 1, end],
    ],
)

%const isEmpty = !^[e: Type] ^[
    elements: ^[e...],
] => length[elements] == 0

%const fold = !^[eT: Type, rT: Type] ^{
    initial: rT,
    combine: ^{acc: rT, el: eT} -> rT,
} => %let {
    innerFold = ^[
        elements: ^[eT...],
    ] => %if isEmpty[elements] (
        %then initial,
        %else %let {
            head = elements(0),
            tail = dropFirst[elements, 1],
        } %in combine{
            acc: head,
            el: innerFold[tail],
        }
    )
} %in innerFold

%const concatAll = !^[eT: Type] ^[
    lists: ^[^[eT...]...],
] -> ^[eT...] => fold{
    initial: [],
    combine: ^{
        acc: ^[eT...],
        el: ^[eT...],
    } => concat[acc, el],
}[lists]

%const concatAllOf = !^[eT: Type, rT: Type] ^[
    elements: ^[eT...],
    extract: ^[e: eT] -> ^[rT...],
] => concatAll[map[elements, extract]]
