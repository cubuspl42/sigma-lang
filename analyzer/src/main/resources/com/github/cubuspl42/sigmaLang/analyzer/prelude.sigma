%def !^[e: Type, te: Type] ^[e...]:maxOf ^[
    transform: ^[e] -> te,
] => max[
    map[this, transform],
]

%const upTo = ^[
    start: Int,
    end: Int,
] -> ^[Int...] => %if start >= end (
    %then [],
    %else concat[
        [start],
        upTo[start + 1, end],
    ],
)

%def !^[e: Type] ^[e...]:isEmpty ^[] => length[this] == 0

%const fold = ^[eT: Type, rT: Type] !=> ^{
    initial: rT,
    combine: ^{acc: rT, el: eT} -> rT,
} => %let {
    innerFold = ^[
        elements: ^[eT...],
    ] => %if elements:isEmpty[] (
        %then initial,
        %else %let {
            head = elements(0),
            tail = dropFirst[elements, 1],
        } %in combine{
            acc: head,
            el: innerFold[tail],
        }
    )
} %in innerFold

%const concatAll = ^[eT: Type]  !=> ^[
    lists: ^[^[eT...]...],
] -> ^[eT...] => fold{
    initial: [],
    combine: ^{
        acc: ^[eT...],
        el: ^[eT...],
    } => concat[acc, el],
}[lists]

%def !^[eT: Type, rT: Type] ^[eT...]:concatAllOf ^[
    extract: ^[e: eT] -> ^[rT...],
] => concatAll[map[this, extract]]

%def !^[inT: Type] ^[inT...]:mapX ^[outT: Type] !=> ^[
    transformFn: ^[inElement: inT] -> outT,
] -> ^[outT...] => map[this, transformFn]
